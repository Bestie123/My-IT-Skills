
# Коррелирующие подзапросы в SQL

## Содержание ^k9p2r4m7x
- [Введение](#^a1b2c3d4e5)
- [Что такое коррелирующие подзапросы?](#^f6g7h8i9j0)
- [Как работают коррелирующие подзапросы](#^k1l2m3n4o5)
- [Синтаксис коррелирующих подзапросов](#^p6q7r8s9t0)
- [Типы коррелирующих подзапросов](#^u1v2w3x4y5)
  - [Коррелирующие подзапросы в SELECT](#^z6a7b8c9d0)
  - [Коррелирующие подзапросы в WHERE](#^e1f2g3h4i5)
  - [Коррелирующие подзапросы с EXISTS](#^j6k7l8m9n0)
  - [Коррелирующие подзапросы в HAVING](#^o1p2q3r4s5)
- [Примеры использования](#^t6u7v8w9x0)
  - [Базовые примеры](#^y1z2a3b4c5)
  - [Практические сценарии](#^d6e7f8g9h0)
  - [Сложные корреляции](#^i1j2k3l4m5)
- [Производительность и оптимизация](#^n6o7p8q9r0)
- [Альтернативы коррелирующим подзапросам](#^s1t2u3v4w5)
- [Лучшие практики](#^x3y4z5a6b7)
- [Заключение](#^c8d9e0f1g2)

## Введение ^a1b2c3d4e5
Коррелирующие подзапросы - это мощный инструмент в SQL, который позволяет создавать подзапросы, ссылающиеся на столбцы внешнего запроса. В отличие от некоррелирующих подзапросов, которые выполняются один раз, коррелирующие подзапросы выполняются для каждой строки внешнего запроса.

<big>**Основные характеристики коррелирующих подзапросов:**</big>

- Ссылаются на столбцы внешнего запроса
- Выполняются для каждой строки результата внешнего запроса
- Позволяют создавать сложные условия и вычисления
- Могут быть менее производительными чем JOIN
- Обеспечивают гибкость в сложных сценариях

<small>Коррелирующие подзапросы также известны как "синхронные подзапросы" или "взаимосвязанные подзапросы".</small>

[↑ К содержанию](#^k9p2r4m7x)

## Что такое коррелирующие подзапросы? ^f6g7h8i9j0
Коррелирующий подзапрос - это внутренний запрос, который содержит ссылку на столбец из внешнего запроса. Эта связь создает зависимость, при которой внутренний запрос должен выполняться для каждой строки внешнего запроса.

**Ключевые отличия от некоррелирующих подзапросов:**

```sql
-- Некоррелирующий подзапрос (выполняется один раз)
SELECT name, salary
FROM employees
WHERE salary > (SELECT AVG(salary) FROM employees);

-- Коррелирующий подзапрос (выполняется для каждой строки)
SELECT name, salary, department_id
FROM employees e1
WHERE salary > (SELECT AVG(salary) 
                FROM employees e2 
                WHERE e2.department_id = e1.department_id);
```

**Разбор различий:**
- **Некоррелирующий**: Вычисляет среднюю зарплату один раз для всей таблицы
- **Коррелирующий**: Вычисляет среднюю зарплату для каждого отдела отдельно, для каждого сотрудника

**Визуализация выполнения:**
```
Внешний запрос: Берет первую строку (сотрудник А, отдел 1)
Внутренний запрос: SELECT AVG(salary) FROM employees WHERE department_id = 1
Сравнение: salary_A > AVG_отдел_1

Внешний запрос: Берет вторую строку (сотрудник Б, отдел 2)  
Внутренний запрос: SELECT AVG(salary) FROM employees WHERE department_id = 2
Сравнение: salary_Б > AVG_отдел_2

... и так для каждой строки
```

[↑ К содержанию](#^k9p2r4m7x)

## Как работают коррелирующие подзапросы ^k1l2m3n4o5
Понимание механизма выполнения коррелирующих подзапросов критически важно для их эффективного использования.

### Процесс выполнения:
1. **Внешний запрос** извлекает первую строку
2. **Коррелирующий подзапрос** выполняется с использованием значений из текущей строки внешнего запроса
3. **Результат подзапроса** используется в условии внешнего запроса
4. Процесс повторяется для **каждой строки** внешнего запроса

### Детальный разбор выполнения:
```sql
SELECT 
    employee_id,
    name,
    salary,
    (SELECT AVG(salary) 
     FROM employees e2 
     WHERE e2.department_id = e1.department_id) as avg_department_salary
FROM employees e1;
```

**Шаги выполнения:**
1. Внешний запрос берет первую строку из employees (например: id=1, name='John', salary=5000, dept_id=10)
2. Подзапрос выполняется: `SELECT AVG(salary) FROM employees WHERE department_id = 10`
3. Результат подзапроса (например: 4500) добавляется к строке John
4. Внешний запрос берет следующую строку (id=2, name='Jane', salary=6000, dept_id=20)
5. Подзапрос выполняется: `SELECT AVG(salary) FROM employees WHERE department_id = 20`
6. Процесс повторяется для всех строк

**Особенности выполнения:**
- Подзапрос выполняется для КАЖДОЙ строки внешнего запроса
- Производительность может значительно снижаться на больших таблицах
- Результат подзапроса зависит от конкретной строки внешнего запроса

[↑ К содержанию](#^k9p2r4m7x)

## Синтаксис коррелирующих подзапросов ^p6q7r8s9t0
Коррелирующие подзапросы могут использоваться в различных частях SQL-запроса с определенным синтаксисом.

### Базовый синтаксис:
```sql
SELECT column1, column2, ...
FROM table1 t1
WHERE column1 OPERATOR (
    SELECT column1 
    FROM table2 t2 
    WHERE t2.correlated_column = t1.correlated_column
);
```

**Ключевые элементы синтаксиса:**
- **Псевдоним внешней таблицы** (t1) - обязателен для ясности
- **Ссылка на внешний столбец** (t1.correlated_column) - создает корреляцию
- **Оператор сравнения** (OPERATOR) - =, >, <, IN, EXISTS и т.д.

### Синтаксис в различных контекстах:

**В SELECT:**
```sql
SELECT 
    column1,
    (SELECT aggregate_function(column2) 
     FROM table2 t2 
     WHERE t2.correlated_column = t1.correlated_column) as calculated_column
FROM table1 t1;
```

**В WHERE:**
```sql
SELECT column1, column2
FROM table1 t1
WHERE column1 OPERATOR (
    SELECT column2 
    FROM table2 t2 
    WHERE t2.correlated_column = t1.correlated_column
);
```

**С EXISTS:**
```sql
SELECT column1, column2
FROM table1 t1
WHERE EXISTS (
    SELECT 1 
    FROM table2 t2 
    WHERE t2.correlated_column = t1.correlated_column
    AND additional_conditions
);
```

[↑ К содержанию](#^k9p2r4m7x)

## Типы коррелирующих подзапросов ^u1v2w3x4y5
### Коррелирующие подзапросы в SELECT ^z6a7b8c9d0
Использование коррелирующих подзапросов в списке SELECT для вычисления значений на основе данных внешнего запроса.

```sql
-- Вычисление относительных показателей
SELECT 
    e.employee_id,
    e.name,
    e.salary,
    e.department_id,
    (SELECT AVG(salary) 
     FROM employees e2 
     WHERE e2.department_id = e.department_id) as avg_department_salary,
    e.salary - (SELECT AVG(salary) 
                FROM employees e2 
                WHERE e2.department_id = e.department_id) as diff_from_avg,
    (SELECT COUNT(*) 
     FROM employees e2 
     WHERE e2.department_id = e.department_id) as employees_in_department
FROM employees e;
```

**Разбор примера:**
- Первый подзапрос вычисляет среднюю зарплату по отделу для каждого сотрудника
- Второй подзапрос вычисляет разницу между зарплатой сотрудника и средней по отделу
- Третий подзапрос подсчитывает количество сотрудников в отделе

**Преимущества:**
- Позволяют вычислять сложные показатели без группировки
- Сохраняют детализацию данных
- Гибкость в расчетах

[↑ К содержанию](#^k9p2r4m7x)

### Коррелирующие подзапросы в WHERE ^e1f2g3h4i5
Использование в условиях WHERE для фильтрации на основе связанных данных.

```sql
-- Найти сотрудников с зарплатой выше средней по их отделу
SELECT 
    employee_id,
    name,
    salary,
    department_id
FROM employees e1
WHERE salary > (SELECT AVG(salary) 
                FROM employees e2 
                WHERE e2.department_id = e1.department_id);

-- Найти товары с ценой выше средней в их категории
SELECT 
    product_id,
    product_name,
    price,
    category_id
FROM products p1
WHERE price > (SELECT AVG(price) 
               FROM products p2 
               WHERE p2.category_id = p1.category_id);
```

**Разбор примеров:**
- Условие WHERE использует результат коррелирующего подзапроса для фильтрации
- Для каждого сотрудника/товара вычисляется своя средняя значение по категории
- Фильтрация происходит на основе сравнения с вычисленным значением

[↑ К содержанию](#^k9p2r4m7x)

### Коррелирующие подзапросы с EXISTS ^j6k7l8m9n0
Использование EXISTS с коррелирующими подзапросами для проверки существования связанных записей.

```sql
-- Найти клиентов, которые делали заказы в последние 30 дней
SELECT 
    customer_id,
    name,
    email
FROM customers c
WHERE EXISTS (SELECT 1 
              FROM orders o 
              WHERE o.customer_id = c.customer_id 
              AND o.order_date >= CURRENT_DATE - INTERVAL '30 days');

-- Найти отделы, в которых есть сотрудники с зарплатой выше 5000
SELECT 
    department_id,
    department_name
FROM departments d
WHERE EXISTS (SELECT 1 
              FROM employees e 
              WHERE e.department_id = d.department_id 
              AND e.salary > 5000);
```

**Разбор синтаксиса EXISTS:**
- `EXISTS` возвращает TRUE если подзапрос возвращает хотя бы одну строку
- `SELECT 1` - обычно используется так как важен только факт существования строк
- Корреляция создается через условие в WHERE подзапроса

**Особенности EXISTS:**
- Подзапрос обычно выполняется быстрее чем с агрегатными функциями
- Не требует полного вычисления подзапроса - достаточно найти первую подходящую строку
- Часто более эффективен чем IN с подзапросом

[↑ К содержанию](#^k9p2r4m7x)

### Коррелирующие подзапросы в HAVING ^o1p2q3r4s5
Использование в предложении HAVING для фильтрации групп на основе коррелированных данных.

```sql
-- Найти отделы, где средняя зарплата выше средней по компании
SELECT 
    department_id,
    AVG(salary) as avg_salary
FROM employees e1
GROUP BY department_id
HAVING AVG(salary) > (SELECT AVG(salary) 
                      FROM employees e2 
                      WHERE e2.department_id != e1.department_id);

-- Найти категории товаров, где количество товаров выше среднего
SELECT 
    category_id,
    COUNT(*) as product_count
FROM products p1
GROUP BY category_id
HAVING COUNT(*) > (SELECT AVG(product_count) 
                   FROM (SELECT COUNT(*) as product_count 
                         FROM products p2 
                         GROUP BY category_id) category_counts);
```

**Разбор примеров:**
- HAVING применяется после группировки
- Коррелирующий подзапрос может ссылаться на сгруппированные данные
- Полезно для сравнительного анализа групп

[↑ К содержанию](#^k9p2r4m7x)

## Примеры использования ^t6u7v8w9x0
### Базовые примеры ^y1z2a3b4c5
Простые примеры, демонстрирующие основные концепции коррелирующих подзапросов.

**Пример 1: Ранжирование внутри групп**
```sql
-- Найти сотрудников с самой высокой зарплатой в каждом отделе
SELECT 
    e1.employee_id,
    e1.name,
    e1.salary,
    e1.department_id
FROM employees e1
WHERE e1.salary = (SELECT MAX(salary) 
                   FROM employees e2 
                   WHERE e2.department_id = e1.department_id);
```

**Пример 2: Поиск дубликатов**
```sql
-- Найти дублирующиеся email адреса
SELECT 
    email,
    COUNT(*) as duplicate_count
FROM users u1
WHERE EXISTS (SELECT 1 
              FROM users u2 
              WHERE u2.email = u1.email 
              AND u2.user_id != u1.user_id)
GROUP BY email;
```

**Пример 3: Сравнение с групповыми показателями**
```sql
-- Сравнить продажи каждого менеджера со средними продажами по региону
SELECT 
    s.salesperson_id,
    s.name,
    s.region,
    s.total_sales,
    (SELECT AVG(total_sales) 
     FROM salespeople s2 
     WHERE s2.region = s.region) as region_avg_sales
FROM salespeople s;
```

[↑ К содержанию](#^k9p2r4m7x)

### Практические сценарии ^d6e7f8g9h0
Реальные бизнес-сценарии использования коррелирующих подзапросов.

**Сценарий 1: Анализ клиентского поведения**
```sql
-- Найти клиентов, которые делали заказы выше среднего чека по их стране
SELECT 
    c.customer_id,
    c.name,
    c.country,
    o.order_id,
    o.total_amount
FROM customers c
JOIN orders o ON c.customer_id = o.customer_id
WHERE o.total_amount > (SELECT AVG(o2.total_amount) 
                        FROM orders o2 
                        JOIN customers c2 ON o2.customer_id = c2.customer_id
                        WHERE c2.country = c.country);
```

**Сценарий 2: Управление запасами**
```sql
-- Найти товары, количество которых на складе ниже среднего по категории
SELECT 
    p.product_id,
    p.product_name,
    p.category_id,
    i.quantity_in_stock,
    (SELECT AVG(i2.quantity_in_stock) 
     FROM inventory i2 
     JOIN products p2 ON i2.product_id = p2.product_id
     WHERE p2.category_id = p.category_id) as avg_category_stock
FROM products p
JOIN inventory i ON p.product_id = i.product_id
WHERE i.quantity_in_stock < (SELECT AVG(i2.quantity_in_stock) 
                             FROM inventory i2 
                             JOIN products p2 ON i2.product_id = p2.product_id
                             WHERE p2.category_id = p.category_id);
```

**Сценарий 3: Анализ эффективности сотрудников**
```sql
-- Найти сотрудников, чья производительность выше средней в их отделе
SELECT 
    e.employee_id,
    e.name,
    e.department_id,
    p.performance_score,
    (SELECT AVG(p2.performance_score) 
     FROM performance p2 
     JOIN employees e2 ON p2.employee_id = e2.employee_id
     WHERE e2.department_id = e.department_id) as dept_avg_performance
FROM employees e
JOIN performance p ON e.employee_id = p.employee_id
WHERE p.performance_score > (SELECT AVG(p2.performance_score) 
                             FROM performance p2 
                             JOIN employees e2 ON p2.employee_id = e2.employee_id
                             WHERE e2.department_id = e.department_id);
```

[↑ К содержанию](#^k9p2r4m7x)

### Сложные корреляции ^i1j2k3l4m5
Продвинутые примеры с множественными корреляциями и сложной логикой.

**Пример 1: Иерархические запросы**
```sql
-- Найти менеджеров, у которых в подчинении есть сотрудники с зарплатой выше средней по отделу
SELECT 
    m.employee_id as manager_id,
    m.name as manager_name,
    d.department_name
FROM employees m
JOIN departments d ON m.department_id = d.department_id
WHERE EXISTS (SELECT 1 
              FROM employees e 
              WHERE e.manager_id = m.employee_id
              AND e.salary > (SELECT AVG(salary) 
                              FROM employees e2 
                              WHERE e2.department_id = e.department_id));
```

**Пример 2: Временные корреляции**
```sql
-- Найти продукты, цена которых увеличилась больше чем на 10% по сравнению с предыдущей ценой
SELECT 
    p1.product_id,
    p1.product_name,
    p1.price as current_price,
    (SELECT p2.price 
     FROM price_history p2 
     WHERE p2.product_id = p1.product_id 
     AND p2.effective_date < p1.effective_date
     ORDER BY p2.effective_date DESC 
     LIMIT 1) as previous_price
FROM price_history p1
WHERE p1.effective_date = (SELECT MAX(effective_date) 
                           FROM price_history p3 
                           WHERE p3.product_id = p1.product_id)
AND p1.price > 1.1 * (SELECT p2.price 
                      FROM price_history p2 
                      WHERE p2.product_id = p1.product_id 
                      AND p2.effective_date < p1.effective_date
                      ORDER BY p2.effective_date DESC 
                      LIMIT 1);
```

**Пример 3: Многоуровневые корреляции**
```sql
-- Анализ вложенных зависимостей
SELECT 
    c.customer_id,
    c.name,
    (SELECT COUNT(*) 
     FROM orders o 
     WHERE o.customer_id = c.customer_id
     AND o.total_amount > (SELECT AVG(total_amount) 
                          FROM orders o2 
                          WHERE o2.customer_id = c.customer_id)) as high_value_orders_count
FROM customers c
WHERE (SELECT COUNT(*) 
       FROM orders o 
       WHERE o.customer_id = c.customer_id) > 5;
```

[↑ К содержанию](#^k9p2r4m7x)

## Производительность и оптимизация ^n6o7p8q9r0
Коррелирующие подзапросы могут создавать проблемы с производительностью, которые необходимо учитывать.

### Анализ производительности:
```sql
-- Проблемный запрос (может быть медленным на больших таблицах)
EXPLAIN ANALYZE
SELECT 
    e1.employee_id,
    e1.name,
    (SELECT AVG(salary) 
     FROM employees e2 
     WHERE e2.department_id = e1.department_id) as avg_salary
FROM employees e1;
```

**Факторы влияющие на производительность:**
- Размер таблиц во внешнем и внутреннем запросах
- Наличие индексов на коррелируемых столбцах
- Сложность условий в подзапросе
- Количество строк во внешнем запросе

### Стратегии оптимизации:

**1. Индексы на коррелируемых столбцах:**
```sql
-- Создание индекса для ускорения коррелирующего подзапроса
CREATE INDEX idx_employees_department_id ON employees(department_id);
CREATE INDEX idx_employees_department_salary ON employees(department_id, salary);
```

**2. Ограничение размера результата:**
```sql
-- Добавление LIMIT к внешнему запросу для тестирования
SELECT 
    e1.employee_id,
    e1.name,
    (SELECT AVG(salary) 
     FROM employees e2 
     WHERE e2.department_id = e1.department_id) as avg_salary
FROM employees e1
LIMIT 100;  -- Ограничение для тестирования производительности
```

**3. Использование EXISTS вместо агрегатных функций:**
```sql
-- Медленно с агрегатной функцией
SELECT employee_id, name
FROM employees e1
WHERE salary > (SELECT AVG(salary) 
                FROM employees e2 
                WHERE e2.department_id = e1.department_id);

-- Быстрее с EXISTS
SELECT e1.employee_id, e1.name
FROM employees e1
WHERE EXISTS (SELECT 1 
              FROM employees e2 
              WHERE e2.department_id = e1.department_id 
              AND e2.salary > e1.salary);
```

<table>
<tr>
<td><strong>Проблема</strong></td>
<td><strong>Симптом</strong></td>
<td><strong>Решение</strong></td>
</tr>
<tr>
<td>Nested Loops</td>
<td>Медленное выполнение на больших таблицах</td>
<td>Добавить индексы на коррелируемых столбцах</td>
</tr>
<tr>
<td>Многократное выполнение</td>
<td>Подзапрос выполняется для каждой строки</td>
<td>Переписать с использованием JOIN или оконных функций</td>
</tr>
<tr>
<td>Отсутствие индексов</td>
<td>Full Table Scan в подзапросе</td>
<td>Создать составные индексы</td>
</tr>
<tr>
<td>Сложная логика</td>
<td>Долгое выполнение подзапроса</td>
<td>Упростить условия или использовать CTE</td>
</tr>
</table>

[↑ К содержанию](#^k9p2r4m7x)

## Альтернативы коррелирующим подзапросам ^s1t2u3v4w5
Во многих случаях существуют более эффективные альтернативы коррелирующим подзапросам.

### Оконные функции:
```sql
-- Вместо коррелирующего подзапроса для среднего по отделу
SELECT 
    employee_id,
    name,
    salary,
    department_id,
    AVG(salary) OVER (PARTITION BY department_id) as avg_department_salary
FROM employees;

-- Вместо коррелирующего подзапроса для максимума по отделу
SELECT 
    employee_id,
    name,
    salary,
    department_id,
    MAX(salary) OVER (PARTITION BY department_id) as max_department_salary
FROM employees;
```

**Преимущества оконных функций:**
- Выполняются за один проход по данным
- Не требуют повторного выполнения для каждой строки
- Часто значительно быстрее коррелирующих подзапросов

### JOIN с агрегацией:
```sql
-- Вместо коррелирующего подзапроса в WHERE
SELECT 
    e1.employee_id,
    e1.name,
    e1.salary,
    e1.department_id
FROM employees e1
JOIN (SELECT department_id, AVG(salary) as avg_salary
      FROM employees 
      GROUP BY department_id) dept_avg 
ON e1.department_id = dept_avg.department_id
WHERE e1.salary > dept_avg.avg_salary;
```

### CTE (Common Table Expressions):
```sql
-- Использование CTE для улучшения читаемости и производительности
WITH department_stats AS (
    SELECT 
        department_id,
        AVG(salary) as avg_salary,
        MAX(salary) as max_salary,
        COUNT(*) as employee_count
    FROM employees
    GROUP BY department_id
)
SELECT 
    e.employee_id,
    e.name,
    e.salary,
    e.department_id,
    ds.avg_salary,
    ds.max_salary,
    ds.employee_count
FROM employees e
JOIN department_stats ds ON e.department_id = ds.department_id
WHERE e.salary > ds.avg_salary;
```

**Сравнение подходов:**

<table>
<tr>
<td><strong>Метод</strong></td>
<td><strong>Производительность</strong></td>
<td><strong>Читаемость</strong></td>
<td><strong>Гибкость</strong></td>
</tr>
<tr>
<td>Коррелирующий подзапрос</td>
<td>Низкая</td>
<td>Средняя</td>
<td>Высокая</td>
</tr>
<tr>
<td>Оконные функции</td>
<td>Высокая</td>
<td>Высокая</td>
<td>Ограниченная</td>
</tr>
<tr>
<td>JOIN + агрегация</td>
<td>Высокая</td>
<td>Средняя</td>
<td>Средняя</td>
</tr>
<tr>
<td>CTE</td>
<td>Высокая</td>
<td>Высокая</td>
<td>Высокая</td>
</tr>
</table>

[↑ К содержанию](#^k9p2r4m7x)

## Лучшие практики ^x3y4z5a6b7
Эффективное использование коррелирующих подзапросов требует соблюдения определенных правил.

### Производительность:
```sql
-- ✅ Хорошо: использование индексированных столбцов для корреляции
SELECT name, salary
FROM employees e1
WHERE salary > (SELECT AVG(salary) 
                FROM employees e2 
                WHERE e2.department_id = e1.department_id);  -- department_id имеет индекс

-- ❌ Плохо: корреляция по неиндексированным столбцам
SELECT name, salary  
FROM employees e1
WHERE salary > (SELECT AVG(salary) 
                FROM employees e2 
                WHERE e2.job_title = e1.job_title);  -- job_title без индекса
```

### Читаемость кода:
```sql
-- ✅ Хорошо: понятные псевдонимы и форматирование
SELECT 
    e.employee_id,
    e.name,
    (SELECT COUNT(*) 
     FROM orders o 
     WHERE o.employee_id = e.employee_id 
     AND o.status = 'COMPLETED') as completed_orders
FROM employees e;

-- ❌ Плохо: непонятные псевдонимы и плохое форматирование
SELECT e1.id, e1.n, (SELECT COUNT(*) FROM ord o WHERE o.emp_id = e1.id AND o.stat = 'C') AS co
FROM emp e1;
```

### Безопасность данных:
```sql
-- ✅ Хорошо: обработка возможных NULL значений
SELECT 
    e.employee_id,
    e.name,
    COALESCE((SELECT MAX(salary) 
              FROM salary_history sh 
              WHERE sh.employee_id = e.employee_id), 0) as highest_salary
FROM employees e;

-- ✅ Использование EXISTS для проверки существования
SELECT 
    d.department_id,
    d.department_name
FROM departments d
WHERE EXISTS (SELECT 1 
              FROM employees e 
              WHERE e.department_id = d.department_id);
```

### Оптимизация сложных запросов:
```sql
-- ✅ Разбиение сложных корреляций на CTE
WITH department_metrics AS (
    SELECT 
        department_id,
        AVG(salary) as avg_salary,
        COUNT(*) as employee_count
    FROM employees
    GROUP BY department_id
),
employee_performance AS (
    SELECT 
        employee_id,
        AVG(performance_score) as avg_performance
    FROM performance_reviews
    GROUP BY employee_id
)
SELECT 
    e.employee_id,
    e.name,
    e.salary,
    dm.avg_salary,
    ep.avg_performance
FROM employees e
JOIN department_metrics dm ON e.department_id = dm.department_id
JOIN employee_performance ep ON e.employee_id = ep.employee_id
WHERE e.salary > dm.avg_salary;
```

<table>
<tr>
<td><strong>Практика</strong></td>
<td><strong>Рекомендация</strong></td>
<td><strong>Пример</strong></td>
</tr>
<tr>
<td>Индексы</td>
<td>Коррелируйте по индексированным столбцам</td>
<td>WHERE e2.department_id = e1.department_id</td>
</tr>
<tr>
<td>Ограничения</td>
<td>Избегайте корреляций в больших таблицах</td>
<td>LIMIT для тестирования</td>
</tr>
<tr>
<td>Альтернативы</td>
<td>Рассматривайте оконные функции</td>
<td>AVG() OVER (PARTITION BY)</td>
</tr>
<tr>
<td>EXISTS</td>
<td>Используйте EXISTS вместо COUNT() > 0</td>
<td>WHERE EXISTS (SELECT 1...)</td>
</tr>
<tr>
<td>CTE</td>
<td>Разбивайте сложные запросы</td>
<td>WITH metrics AS (...)</td>
</tr>
</table>

[↑ К содержанию](#^k9p2r4m7x)

## Заключение ^c8d9e0f1g2
Коррелирующие подзапросы являются мощным инструментом в SQL, предоставляющим уникальные возможности для создания сложных запросов с контекстно-зависимыми вычислениями.

<big>**Ключевые преимущества коррелирующих подзапросов:**</big>

- **Гибкость**: Возможность создания сложных условий на основе данных внешнего запроса
- **Точность**: Точечные вычисления для каждой строки с учетом ее контекста
- **Мощность**: Решение задач, сложно реализуемых другими методами
- **Читаемость**: Прямое отражение бизнес-логики в структуре запроса

<big>**Основные сценарии применения:**</big>

- Сравнительный анализ внутри групп (отделов, категорий, регионов)
- Поиск экстремальных значений в контексте (максимумы/минимумы по группам)
- Проверка сложных условий существования связанных данных
- Вычисление относительных показателей и метрик

**Критические рекомендации:**
- Всегда анализируйте производительность на реалистичных объемах данных
- Используйте индексы на столбцах, участвующих в корреляции
- Рассматривайте оконные функции как альтернативу для агрегатных вычислений
- Применяйте EXISTS вместо агрегатных функций когда важен только факт существования
- Разбивайте сложные запросы на CTE для улучшения читаемости и производительности

Коррелирующие подзапросы, при правильном использовании, остаются незаменимым инструментом для решения сложных аналитических задач в SQL.

[↑ К содержанию](#^k9p2r4m7x)

**Теги:** #sql #коррелирующие-подзапросы #подзапросы #производительность #оптимизация-запросов #базы-данных
```