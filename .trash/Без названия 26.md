<h1>Документация по явным операциям соединения в SQL</h1>

<h2>Содержание</h2>
<ul>
<li><a href="#введение-в-join"><strong>Введение в JOIN</strong></a></li>
<li><a href="#типы-join-операций"><strong>Типы JOIN операций</strong></a></li>
<li><a href="#inner-join"><strong>INNER JOIN</strong></a></li>
<li><a href="#left-join"><strong>LEFT JOIN</strong></a></li>
<li><a href="#right-join"><strong>RIGHT JOIN</strong></a></li>
<li><a href="#full-outer-join"><strong>FULL OUTER JOIN</strong></a></li>
<li><a href="#cross-join"><strong>CROSS JOIN</strong></a></li>
<li><a href="#self-join"><strong>SELF JOIN</strong></a></li>
<li><a href="#множественные-join"><strong>Множественные JOIN</strong></a></li>
<li><a href="#join-с-условиями-where"><strong>JOIN с условиями WHERE</strong></a></li>
<li><a href="#производительность-join"><strong>Производительность JOIN</strong></a></li>
<li><a href="#лучшие-практики"><strong>Лучшие практики</strong></a></li>
</ul>

<!-- Введение в JOIN -->
<h2 id="введение-в-join"><strong>Введение в JOIN</strong></h2>
<p>JOIN (соединение) - это операция в SQL, которая позволяет объединять данные из двух или более таблиц на основе связанных столбцов между ними. JOIN является фундаментальной операцией в реляционных базах данных.</p>

<p><strong>Основные понятия:</strong></p>
<ul>
<li><strong>Таблицы</strong> - источники данных</li>
<li><strong>Ключи</strong> - столбцы, по которым происходит соединение</li>
<li><strong>Условие соединения</strong> - правило, определяющее как таблицы связаны</li>
</ul>

<pre><code class="sql">-- Базовая структура JOIN
SELECT столбцы
FROM таблица1
JOIN таблица2 ON условие_соединения;
</code></pre>

<!-- Типы JOIN операций -->
<h2 id="типы-join-операций"><strong>Типы JOIN операций</strong></h2>
<p>В SQL существуют несколько типов JOIN операций, каждая из которых возвращает разные результаты:</p>

<table>
<thead>
<tr>
<th>Тип JOIN</th>
<th>Описание</th>
<th>Визуальное представление</th>
</tr>
</thead>
<tbody>
<tr>
<td>INNER JOIN</td>
<td>Возвращает только совпадающие строки из обеих таблиц</td>
<td>Пересечение множеств</td>
</tr>
<tr>
<td>LEFT JOIN</td>
<td>Возвращает все строки из левой таблицы и совпадающие из правой</td>
<td>Все левое + пересечение</td>
</tr>
<tr>
<td>RIGHT JOIN</td>
<td>Возвращает все строки из правой таблицы и совпадающие из левой</td>
<td>Все правое + пересечение</td>
</tr>
<tr>
<td>FULL OUTER JOIN</td>
<td>Возвращает все строки из обеих таблиц</td>
<td>Объединение множеств</td>
</tr>
<tr>
<td>CROSS JOIN</td>
<td>Возвращает декартово произведение таблиц</td>
<td>Все комбинации</td>
</tr>
</tbody>
</table>

<!-- INNER JOIN -->
<h2 id="inner-join"><strong>INNER JOIN</strong></h2>
<p>INNER JOIN возвращает только те строки, для которых условие соединения истинно в обеих таблицах.</p>

<pre><code class="sql">-- Синтаксис INNER JOIN
SELECT столбцы
FROM таблица1
INNER JOIN таблица2 ON таблица1.столбец = таблица2.столбец;
</code></pre>

<p><strong>Пример с подробным объяснением:</strong></p>

<pre><code class="sql">-- Создадим тестовые таблицы
CREATE TABLE employees (
    id INT PRIMARY KEY,
    name VARCHAR(50),
    department_id INT
);

CREATE TABLE departments (
    id INT PRIMARY KEY,
    department_name VARCHAR(50)
);

-- INNER JOIN пример
SELECT e.name, d.department_name
FROM employees e
INNER JOIN departments d ON e.department_id = d.id;
</code></pre>

<p><strong>Объяснение для новичков:</strong></p>
<ul>
<li><code>employees e</code> и <code>departments d</code> - это псевдонимы таблиц для удобства</li>
<li><code>ON e.department_id = d.id</code> - условие соединения</li>
<li>Результат будет содержать только сотрудников, у которых есть отдел в таблице departments</li>
<li>Сотрудники без отдела и отделы без сотрудников не будут включены в результат</li>
</ul>

<table>
<thead>
<tr>
<th>employees</th>
<th>departments</th>
<th>INNER JOIN результат</th>
</tr>
</thead>
<tbody>
<tr>
<td>id: 1, name: "Иван", department_id: 1<br>id: 2, name: "Мария", department_id: 2<br>id: 3, name: "Петр", department_id: NULL</td>
<td>id: 1, department_name: "IT"<br>id: 2, department_name: "HR"<br>id: 3, department_name: "Finance"</td>
<td>Иван - IT<br>Мария - HR</td>
</tr>
</tbody>
</table>

<!-- LEFT JOIN -->
<h2 id="left-join"><strong>LEFT JOIN</strong></h2>
<p>LEFT JOIN возвращает все строки из левой таблицы и совпадающие строки из правой таблицы. Если совпадений нет, возвращается NULL для правой таблицы.</p>

<pre><code class="sql">-- Синтаксис LEFT JOIN
SELECT столбцы
FROM таблица1
LEFT JOIN таблица2 ON таблица1.столбец = таблица2.столбец;
</code></pre>

<p><strong>Пример с подробным объяснением:</strong></p>

<pre><code class="sql">-- LEFT JOIN пример
SELECT e.name, d.department_name
FROM employees e
LEFT JOIN departments d ON e.department_id = d.id;
</code></pre>

<p><strong>Объяснение для новичков:</strong></p>
<ul>
<li>Все сотрудники из таблицы employees будут в результате</li>
<li>Для сотрудников без отдела в столбце department_name будет NULL</li>
<li>Отделы без сотрудников не будут показаны</li>
</ul>

<table>
<thead>
<tr>
<th>employees</th>
<th>departments</th>
<th>LEFT JOIN результат</th>
</tr>
</thead>
<tbody>
<tr>
<td>id: 1, name: "Иван", department_id: 1<br>id: 2, name: "Мария", department_id: 2<br>id: 3, name: "Петр", department_id: NULL</td>
<td>id: 1, department_name: "IT"<br>id: 2, department_name: "HR"<br>id: 3, department_name: "Finance"</td>
<td>Иван - IT<br>Мария - HR<br>Петр - NULL</td>
</tr>
</tbody>
</table>

<!-- RIGHT JOIN -->
<h2 id="right-join"><strong>RIGHT JOIN</strong></h2>
<p>RIGHT JOIN возвращает все строки из правой таблицы и совпадающие строки из левой таблицы. Если совпадений нет, возвращается NULL для левой таблицы.</p>

<pre><code class="sql">-- Синтаксис RIGHT JOIN
SELECT столбцы
FROM таблица1
RIGHT JOIN таблица2 ON таблица1.столбец = таблица2.столбец;
</code></pre>

<p><strong>Пример с подробным объяснением:</strong></p>

<pre><code class="sql">-- RIGHT JOIN пример
SELECT e.name, d.department_name
FROM employees e
RIGHT JOIN departments d ON e.department_id = d.id;
</code></pre>

<p><strong>Объяснение для новичков:</strong></p>
<ul>
<li>Все отделы из таблицы departments будут в результате</li>
<li>Для отделов без сотрудников в столбце name будет NULL</li>
<li>Сотрудники без отдела не будут показаны</li>
</ul>

<table>
<thead>
<tr>
<th>employees</th>
<th>departments</th>
<th>RIGHT JOIN результат</th>
</tr>
</thead>
<tbody>
<tr>
<td>id: 1, name: "Иван", department_id: 1<br>id: 2, name: "Мария", department_id: 2<br>id: 3, name: "Петр", department_id: NULL</td>
<td>id: 1, department_name: "IT"<br>id: 2, department_name: "HR"<br>id: 3, department_name: "Finance"</td>
<td>Иван - IT<br>Мария - HR<br>NULL - Finance</td>
</tr>
</tbody>
</table>

<!-- FULL OUTER JOIN -->
<h2 id="full-outer-join"><strong>FULL OUTER JOIN</strong></h2>
<p>FULL OUTER JOIN возвращает все строки из обеих таблиц. Если совпадений нет, возвращается NULL для отсутствующих данных.</p>

<pre><code class="sql">-- Синтаксис FULL OUTER JOIN
SELECT столбцы
FROM таблица1
FULL OUTER JOIN таблица2 ON таблица1.столбец = таблица2.столбец;
</code></pre>

<p><strong>Пример с подробным объяснением:</strong></p>

<pre><code class="sql">-- FULL OUTER JOIN пример (работает в PostgreSQL, SQL Server)
SELECT e.name, d.department_name
FROM employees e
FULL OUTER JOIN departments d ON e.department_id = d.id;
</code></pre>

<p><strong>Объяснение для новичков:</strong></p>
<ul>
<li>Будут показаны все сотрудники и все отделы</li>
<li>Для сотрудников без отдела department_name будет NULL</li>
<li>Для отделов без сотрудников name будет NULL</li>
</ul>

<table>
<thead>
<tr>
<th>employees</th>
<th>departments</th>
<th>FULL OUTER JOIN результат</th>
</tr>
</thead>
<tbody>
<tr>
<td>id: 1, name: "Иван", department_id: 1<br>id: 2, name: "Мария", department_id: 2<br>id: 3, name: "Петр", department_id: NULL</td>
<td>id: 1, department_name: "IT"<br>id: 2, department_name: "HR"<br>id: 3, department_name: "Finance"</td>
<td>Иван - IT<br>Мария - HR<br>Петр - NULL<br>NULL - Finance</td>
</tr>
</tbody>
</table>

<p><strong>Примечание:</strong> В MySQL FULL OUTER JOIN не поддерживается напрямую, но можно эмулировать через UNION:</p>

<pre><code class="sql">-- Эмуляция FULL OUTER JOIN в MySQL
SELECT e.name, d.department_name
FROM employees e
LEFT JOIN departments d ON e.department_id = d.id
UNION
SELECT e.name, d.department_name
FROM employees e
RIGHT JOIN departments d ON e.department_id = d.id;
</code></pre>

<!-- CROSS JOIN -->
<h2 id="cross-join"><strong>CROSS JOIN</strong></h2>
<p>CROSS JOIN возвращает декартово произведение таблиц - каждая строка первой таблицы соединяется с каждой строкой второй таблицы.</p>

<pre><code class="sql">-- Синтаксис CROSS JOIN
SELECT столбцы
FROM таблица1
CROSS JOIN таблица2;
</code></pre>

<p><strong>Пример с подробным объяснением:</strong></p>

<pre><code class="sql">-- CROSS JOIN пример
SELECT e.name, d.department_name
FROM employees e
CROSS JOIN departments d;
</code></pre>

<p><strong>Объяснение для новичков:</strong></p>
<ul>
<li>Если в employees 3 строки, а в departments 3 строки, результат будет 9 строк</li>
<li>Каждый сотрудник будет соединен с каждым отделом</li>
<li>Полезно для создания всех возможных комбинаций</li>
</ul>

<table>
<thead>
<tr>
<th>employees (3 строки)</th>
<th>departments (3 строки)</th>
<th>CROSS JOIN результат (9 строк)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Иван, Мария, Петр</td>
<td>IT, HR, Finance</td>
<td>Иван - IT<br>Иван - HR<br>Иван - Finance<br>Мария - IT<br>Мария - HR<br>Мария - Finance<br>Петр - IT<br>Петр - HR<br>Петр - Finance</td>
</tr>
</tbody>
</table>

<!-- SELF JOIN -->
<h2 id="self-join"><strong>SELF JOIN</strong></h2>
<p>SELF JOIN - это соединение таблицы с самой собой. Полезно для иерархических данных.</p>

<pre><code class="sql">-- Синтаксис SELF JOIN
SELECT a.столбцы, b.столбцы
FROM таблица a
JOIN таблица b ON условие;
</code></pre>

<p><strong>Пример с подробным объяснением:</strong></p>

<pre><code class="sql">-- Создадим таблицу сотрудников с менеджерами
CREATE TABLE employees_hierarchy (
    id INT PRIMARY KEY,
    name VARCHAR(50),
    manager_id INT
);

-- SELF JOIN пример: сотрудники и их менеджеры
SELECT e.name AS employee_name, m.name AS manager_name
FROM employees_hierarchy e
LEFT JOIN employees_hierarchy m ON e.manager_id = m.id;
</code></pre>

<p><strong>Объяснение для новичков:</strong></p>
<ul>
<li>Таблица employees_hierarchy используется дважды с разными псевдонимами</li>
<li><code>e</code> представляет сотрудников</li>
<li><code>m</code> представляет менеджеров</li>
<li>LEFT JOIN используется чтобы включить сотрудников без менеджеров</li>
</ul>

<table>
<thead>
<tr>
<th>employees_hierarchy</th>
<th>SELF JOIN результат</th>
</tr>
</thead>
<tbody>
<tr>
<td>id: 1, name: "Анна", manager_id: NULL<br>id: 2, name: "Борис", manager_id: 1<br>id: 3, name: "Виктор", manager_id: 1<br>id: 4, name: "Галина", manager_id: 2</td>
<td>Анна - NULL<br>Борис - Анна<br>Виктор - Анна<br>Галина - Борис</td>
</tr>
</tbody>
</table>

<!-- Множественные JOIN -->
<h2 id="множественные-join"><strong>Множественные JOIN</strong></h2>
<p>Можно соединять более двух таблиц в одном запросе.</p>

<pre><code class="sql">-- Синтаксис множественных JOIN
SELECT столбцы
FROM таблица1
JOIN таблица2 ON условие1
JOIN таблица3 ON условие2
...;
</code></pre>

<p><strong>Пример с подробным объяснением:</strong></p>

<pre><code class="sql">-- Добавим таблицу проектов
CREATE TABLE projects (
    id INT PRIMARY KEY,
    project_name VARCHAR(50),
    department_id INT
);

-- Множественные JOIN: сотрудники, отделы, проекты
SELECT e.name, d.department_name, p.project_name
FROM employees e
INNER JOIN departments d ON e.department_id = d.id
INNER JOIN projects p ON d.id = p.department_id;
</code></pre>

<p><strong>Объяснение для новичков:</strong></p>
<ul>
<li>Сначала соединяются employees и departments</li>
<li>Затем результат соединяется с projects</li>
<li>Порядок JOIN важен для производительности</li>
<li>Можно использовать разные типы JOIN в одном запросе</li>
</ul>

<pre><code class="sql">-- Смешанные типы JOIN
SELECT e.name, d.department_name, p.project_name
FROM employees e
LEFT JOIN departments d ON e.department_id = d.id
LEFT JOIN projects p ON d.id = p.department_id;
</code></pre>

<!-- JOIN с условиями WHERE -->
<h2 id="join-с-условиями-where"><strong>JOIN с условиями WHERE</strong></h2>
<p>JOIN можно комбинировать с условиями WHERE для фильтрации результатов.</p>

<pre><code class="sql">-- JOIN с WHERE
SELECT столбцы
FROM таблица1
JOIN таблица2 ON условие_соединения
WHERE условия_фильтрации;
</code></pre>

<p><strong>Пример с подробным объяснением:</strong></p>

<pre><code class="sql">-- INNER JOIN с фильтрацией
SELECT e.name, d.department_name, e.salary
FROM employees e
INNER JOIN departments d ON e.department_id = d.id
WHERE d.department_name = 'IT' AND e.salary > 50000;

-- LEFT JOIN с фильтрацией по правой таблице
SELECT e.name, d.department_name
FROM employees e
LEFT JOIN departments d ON e.department_id = d.id
WHERE d.department_name IS NULL;  -- Сотрудники без отдела
</code></pre>

<p><strong>Объяснение для новичков:</strong></p>
<ul>
<li>WHERE применяется после выполнения JOIN</li>
<li>Условия в WHERE фильтруют уже соединенные данные</li>
<li>Для поиска NULL значений используйте IS NULL / IS NOT NULL</li>
</ul>

<!-- Производительность JOIN -->
<h2 id="производительность-join"><strong>Производительность JOIN</strong></h2>

<table>
<thead>
<tr>
<th>Фактор</th>
<th>Влияние на производительность</th>
<th>Рекомендации</th>
</tr>
</thead>
<tbody>
<tr>
<td>Индексы</td>
<td>Критически важны</td>
<td>Создавайте индексы на столбцах соединения</td>
</tr>
<tr>
<td>Размер таблиц</td>
<td>Прямое влияние</td>
<td>Начинайте JOIN с наименьшей таблицы</td>
</tr>
<tr>
<td>Тип JOIN</td>
<td>INNER JOIN обычно быстрее</td>
<td>Используйте минимально необходимый тип JOIN</td>
</tr>
<tr>
<td>Условия WHERE</td>
<td>Могут ускорить запрос</td>
<td>Фильтруйте данные как можно раньше</td>
</tr>
</tbody>
</table>

<p><strong>Пример оптимизации:</strong></p>

<pre><code class="sql">-- Медленный запрос (без индексов)
SELECT *
FROM large_table1
JOIN large_table2 ON large_table1.id = large_table2.table1_id;

-- Быстрый запрос (с индексами)
CREATE INDEX idx_table1_id ON large_table1(id);
CREATE INDEX idx_table2_table1_id ON large_table2(table1_id);

SELECT large_table1.column1, large_table2.column2
FROM large_table1
JOIN large_table2 ON large_table1.id = large_table2.table1_id
WHERE large_table1.category = 'A';
</code></pre>

<!-- Лучшие практики -->
<h2 id="лучшие-практики"><strong>Лучшие практики</strong></h2>

<table>
<thead>
<tr>
<th>Практика</th>
<th>Пример</th>
<th>Объяснение</th>
</tr>
</thead>
<tbody>
<tr>
<td>Используйте псевдонимы</td>
<td><code>FROM employees e</code></td>
<td>Упрощает написание запросов</td>
</tr>
<tr>
<td>Явно указывайте INNER</td>
<td><code>INNER JOIN</code> вместо <code>JOIN</code></td>
<td>Делает код более читаемым</td>
</tr>
<tr>
<td>Используйте EXISTS для проверки существования</td>
<td><code>WHERE EXISTS (subquery)</code></td>
<td>Часто эффективнее чем JOIN</td>
</tr>
<tr>
<td>Ограничивайте выбираемые столбцы</td>
<td><code>SELECT e.name, d.department_name</code></td>
<td>Улучшает производительность</td>
</tr>
<tr>
<td>Проверяйте планы выполнения</td>
<td><code>EXPLAIN SELECT ...</code></td>
<td>Помогает оптимизировать запросы</td>
</tr>
</tbody>
</table>

<p><strong>Пример хорошего стиля:</strong></p>

<pre><code class="sql">-- Хорошо написанный запрос
SELECT 
    e.employee_name,
    d.department_name,
    p.project_name
FROM employees e
    INNER JOIN departments d ON e.department_id = d.dept_id
    LEFT JOIN projects p ON d.dept_id = p.department_id
WHERE e.hire_date > '2020-01-01'
    AND d.active = true
ORDER BY e.employee_name;
</code></pre>

<h2>Теги для навигации</h2>
<p>#SQL #JOIN #INNER_JOIN #LEFT_JOIN #RIGHT_JOIN #FULL_OUTER_JOIN #CROSS_JOIN #SELF_JOIN #базы_данных #SQL_оптимизация</p>

<h2>Связанные темы</h2>
<p>#SQL_базовые_операции #индексы_SQL #подзапросы_SQL #оптимизация_запросов #реляционные_базы_данных</p>