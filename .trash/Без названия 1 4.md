```markdown
# Явные операции соединения в SQL

## Содержание
1. [Введение в соединения SQL](#введение-в-соединения-sql)
2. [Типы явных соединений](#типы-явных-соединений)
3. [INNER JOIN](#inner-join)
   - [Синтаксис INNER JOIN](#синтаксис-inner-join)
   - [Примеры INNER JOIN](#примеры-inner-join)
4. [LEFT JOIN](#left-join)
   - [Синтаксис LEFT JOIN](#синтаксис-left-join)
   - [Примеры LEFT JOIN](#примеры-left-join)
5. [RIGHT JOIN](#right-join)
   - [Синтаксис RIGHT JOIN](#синтаксис-right-join)
   - [Примеры RIGHT JOIN](#примеры-right-join)
6. [FULL OUTER JOIN](#full-outer-join)
   - [Синтаксис FULL OUTER JOIN](#синтаксис-full-outer-join)
   - [Примеры FULL OUTER JOIN](#примеры-full-outer-join)
7. [CROSS JOIN](#cross-join)
   - [Синтаксис CROSS JOIN](#синтаксис-cross-join)
   - [Примеры CROSS JOIN](#примеры-cross-join)
8. [Множественные соединения](#множественные-соединения)
9. [Соединения с условиями WHERE](#соединения-с-условиями-where)
10. [Лучшие практики](#лучшие-практики)
11. [Частые ошибки](#частые-ошибки)

<span id="введение-в-соединения-sql"></span>
## **Введение в соединения SQL**

<big>Соединения (JOIN) в SQL — это одна из самых важных и мощных возможностей языка, позволяющая объединять данные из нескольких таблиц в одном запросе.</big>

SQL соединения используются для комбинирования строк из двух или более таблиц на основе связанного столбца между ними. Без соединений нам пришлось бы выполнять множество отдельных запросов и вручную связывать данные.

<small>**Основная концепция**: Соединения работают путем сопоставления значений в указанных столбцах из разных таблиц.</small>

[↑ К содержанию](#содержание)

<span id="типы-явных-соединений"></span>
## **Типы явных соединений**

<big>В SQL существует несколько типов явных соединений, каждый из которых служит определенной цели.</big>

Явные соединения используют ключевое слово `JOIN` и явно указывают условия соединения. Основные типы:

<table border="1" style="width:100%">
<tr>
    <th>Тип соединения</th>
    <th>Описание</th>
    <th>Когда использовать</th>
</tr>
<tr>
    <td>INNER JOIN</td>
    <td>Возвращает только совпадающие строки из обеих таблиц</td>
    <td>Когда нужны только общие данные</td>
</tr>
<tr>
    <td>LEFT JOIN</td>
    <td>Возвращает все строки из левой таблицы и совпадающие из правой</td>
    <td>Когда нужны все данные из основной таблицы</td>
</tr>
<tr>
    <td>RIGHT JOIN</td>
    <td>Возвращает все строки из правой таблицы и совпадающие из левой</td>
    <td>Когда нужны все данные из связанной таблицы</td>
</tr>
<tr>
    <td>FULL OUTER JOIN</td>
    <td>Возвращает все строки из обеих таблиц</td>
    <td>Когда нужны все данные из обеих таблиц</td>
</tr>
<tr>
    <td>CROSS JOIN</td>
    <td>Возвращает декартово произведение таблиц</td>
    <td>Для комбинаций всех записей</td>
</tr>
</table>

[↑ К содержанию](#содержание)

<span id="inner-join"></span>
## **INNER JOIN**

<big>INNER JOIN — самый распространенный тип соединения, который возвращает только те строки, для которых есть совпадения в обеих таблицах.</big>

<span id="синтаксис-inner-join"></span>
### **Синтаксис INNER JOIN**

```sql
SELECT столбцы
FROM таблица1
INNER JOIN таблица2 ON таблица1.столбец = таблица2.столбец;
```

<small>Пояснение:

· INNER JOIN указывает тип соединения
· ON определяет условие соединения
· Сравниваются значения в указанных столбцах
· Возвращаются только строки, где условие истинно</small>

<span id="примеры-inner-join"></span>

Примеры INNER JOIN

Пример 1: Простое соединение двух таблиц

```sql
-- Создадим тестовые таблицы
CREATE TABLE employees (
    id INT PRIMARY KEY,
    name VARCHAR(50),
    department_id INT
);

CREATE TABLE departments (
    id INT PRIMARY KEY,
    department_name VARCHAR(50)
);

-- INNER JOIN пример
SELECT e.name, d.department_name
FROM employees e
INNER JOIN departments d ON e.department_id = d.id;
```

<small>Объяснение для новичков:

· employees e и departments d — это алиасы (псевдонимы) таблиц
· e.department_id = d.id — условие соединения
· Запрос вернет только сотрудников, у которых есть отдел в таблице departments</small>

Пример 2: INNER JOIN с несколькими условиями

```sql
SELECT e.name, d.department_name, p.project_name
FROM employees e
INNER JOIN departments d ON e.department_id = d.id
INNER JOIN projects p ON e.id = p.employee_id
WHERE d.department_name = 'IT';
```

↑ К содержанию

<span id="left-join"></span>

LEFT JOIN

<big>LEFT JOIN возвращает все строки из левой таблицы и совпадающие строки из правой таблицы. Если совпадений нет, возвращается NULL для столбцов правой таблицы.</big>

<span id="синтаксис-left-join"></span>

Синтаксис LEFT JOIN

```sql
SELECT столбцы
FROM таблица1
LEFT JOIN таблица2 ON таблица1.столбец = таблица2.столбец;
```

<span id="примеры-left-join"></span>

Примеры LEFT JOIN

Пример 1: Поиск сотрудников без отделов

```sql
SELECT e.name, d.department_name
FROM employees e
LEFT JOIN departments d ON e.department_id = d.id
WHERE d.id IS NULL;
```

<small>Объяснение: Этот запрос найдет всех сотрудников, которые не привязаны к какому-либо отделу.</small>

Пример 2: LEFT JOIN с агрегатными функциями

```sql
SELECT d.department_name, COUNT(e.id) as employee_count
FROM departments d
LEFT JOIN employees e ON d.id = e.department_id
GROUP BY d.department_name;
```

```sql
-- Результат будет выглядеть примерно так:
<table border="1" style="width:60%">
<tr>
    <th>department_name</th>
    <th>employee_count</th>
</tr>
<tr>
    <td>IT</td>
    <td>5</td>
</tr>
<tr>
    <td>HR</td>
    <td>3</td>
</tr>
<tr>
    <td>Marketing</td>
    <td>0</td>
</tr>
</table>
```

↑ К содержанию

<span id="right-join"></span>

RIGHT JOIN

<big>RIGHT JOIN возвращает все строки из правой таблицы и совпадающие строки из левой таблицы. Если совпадений нет, возвращается NULL для столбцов левой таблицы.</big>

<span id="синтаксис-right-join"></span>

Синтаксис RIGHT JOIN

```sql
SELECT столбцы
FROM таблица1
RIGHT JOIN таблица2 ON таблица1.столбец = таблица2.столбец;
```

<span id="примеры-right-join"></span>

Примеры RIGHT JOIN

Пример: Поиск отделов без сотрудников

```sql
SELECT d.department_name, e.name
FROM employees e
RIGHT JOIN departments d ON e.department_id = d.id
WHERE e.id IS NULL;
```

<small>Важно: RIGHT JOIN используется реже чем LEFT JOIN, так как те же результаты можно получить, поменяв таблицы местами и используя LEFT JOIN.</small>

Эквивалентные запросы:

```sql
-- С RIGHT JOIN
SELECT d.department_name, e.name
FROM employees e
RIGHT JOIN departments d ON e.department_id = d.id
WHERE e.id IS NULL;

-- Тот же результат с LEFT JOIN
SELECT d.department_name, e.name
FROM departments d
LEFT JOIN employees e ON d.id = e.department_id
WHERE e.id IS NULL;
```

↑ К содержанию

<span id="full-outer-join"></span>

FULL OUTER JOIN

<big>FULL OUTER JOIN возвращает все строки из обеих таблиц, объединяя результаты LEFT и RIGHT JOIN.</big>

<span id="синтаксис-full-outer-join"></span>

Синтаксис FULL OUTER JOIN

```sql
SELECT столбцы
FROM таблица1
FULL OUTER JOIN таблица2 ON таблица1.столбец = таблица2.столбец;
```

<span id="примеры-full-outer-join"></span>

Примеры FULL OUTER JOIN

Пример: Полный анализ связей между таблицами

```sql
SELECT 
    COALESCE(e.name, 'Нет сотрудника') as employee_name,
    COALESCE(d.department_name, 'Нет отдела') as department_name
FROM employees e
FULL OUTER JOIN departments d ON e.department_id = d.id;
```

<small>Объяснение:

· COALESCE возвращает первое не-NULL значение
· Этот запрос покажет:
  · Сотрудников с отделами
  · Сотрудников без отделов
  · Отделы без сотрудников</small>

```sql
-- Пример результата:
<table border="1" style="width:70%">
<tr>
    <th>employee_name</th>
    <th>department_name</th>
</tr>
<tr>
    <td>Иван Иванов</td>
    <td>IT</td>
</tr>
<tr>
    <td>Петр Петров</td>
    <td>HR</td>
</tr>
<tr>
    <td>Нет сотрудника</td>
    <td>Marketing</td>
</tr>
<tr>
    <td>Сергей Сергеев</td>
    <td>Нет отдела</td>
</tr>
</table>
```

↑ К содержанию

<span id="cross-join"></span>

CROSS JOIN

<big>CROSS JOIN возвращает декартово произведение таблиц — каждая строка первой таблицы соединяется с каждой строкой второй таблицы.</big>

<span id="синтаксис-cross-join"></span>

Синтаксис CROSS JOIN

```sql
SELECT столбцы
FROM таблица1
CROSS JOIN таблица2;
```

<span id="примеры-cross-join"></span>

Примеры CROSS JOIN

Пример 1: Создание всех возможных комбинаций

```sql
-- Таблица размеров
CREATE TABLE sizes (
    size_name VARCHAR(10)
);

-- Таблица цветов
CREATE TABLE colors (
    color_name VARCHAR(20)
);

-- CROSS JOIN для создания всех комбинаций
SELECT s.size_name, c.color_name
FROM sizes s
CROSS JOIN colors c;
```

Пример 2: CROSS JOIN для генерации данных

```sql
-- Создание календаря на месяц
WITH numbers AS (
    SELECT 1 as day_num
    UNION SELECT 2 UNION SELECT 3 UNION SELECT 4 UNION SELECT 5
    -- и так далее до 31
)
SELECT n.day_num as day_number
FROM numbers n
CROSS JOIN (SELECT 'January' as month_name) m;
```

↑ К содержанию

<span id="множественные-соединения"></span>

Множественные соединения

<big>В реальных сценариях часто требуется соединять более двух таблиц в одном запросе.</big>

Пример сложного запроса с множественными соединениями:

```sql
SELECT 
    e.name as employee_name,
    d.department_name,
    p.project_name,
    m.name as manager_name
FROM employees e
INNER JOIN departments d ON e.department_id = d.id
LEFT JOIN projects p ON e.id = p.employee_id
LEFT JOIN employees m ON e.manager_id = m.id
WHERE d.department_name = 'IT'
ORDER BY e.name;
```

<small>Пояснение структуры:

· Сначала соединяем employees с departments (INNER JOIN)
· Затем добавляем projects (LEFT JOIN — если у сотрудника нет проектов)
· Наконец, добавляем информацию о менеджере (LEFT JOIN — если нет менеджера)</small>

Визуализация порядка выполнения:

```sql
-- Псевдокод порядка выполнения
1. FROM employees e
2. INNER JOIN departments d ON e.department_id = d.id
3. LEFT JOIN projects p ON e.id = p.employee_id  
4. LEFT JOIN employees m ON e.manager_id = m.id
5. WHERE d.department_name = 'IT'
6. SELECT указанные столбцы
7. ORDER BY e.name
```

↑ К содержанию

<span id="соединения-с-условиями-where"></span>

Соединения с условиями WHERE

<big>Условия WHERE и JOIN можно комбинировать для точной фильтрации результатов.</big>

Важные отличия:

```sql
-- Условие в ON (фильтрация перед соединением)
SELECT e.name, d.department_name
FROM employees e
LEFT JOIN departments d ON e.department_id = d.id AND d.department_name = 'IT';

-- Условие в WHERE (фильтрация после соединения)  
SELECT e.name, d.department_name
FROM employees e
LEFT JOIN departments d ON e.department_id = d.id
WHERE d.department_name = 'IT' OR d.department_name IS NULL;
```

Практический пример с разными подходами:

```sql
-- Найти IT сотрудников с зарплатой выше средней
SELECT e.name, e.salary, d.department_name
FROM employees e
INNER JOIN departments d ON e.department_id = d.id
WHERE d.department_name = 'IT'
AND e.salary > (
    SELECT AVG(salary) 
    FROM employees 
    WHERE department_id = d.id
);
```

↑ К содержанию

<span id="лучшие-практики"></span>

Лучшие практики

<big>Следование лучшим практикам делает запросы эффективнее и понятнее.</big>

<table border="1" style="width:100%">
<tr>
    <th>Практика</th>
    <th>Пример</th>
    <th>Объяснение</th>
</tr>
<tr>
    <td>Используйте алиасы</td>
    <td><code>FROM employees e</code></td>
    <td>Упрощает чтение и написание запросов</td>
</tr>
<tr>
    <td>Явные условия JOIN</td>
    <td><code>ON e.id = d.employee_id</code></td>
    <td>Избегайте неявных соединений через WHERE</td>
</tr>
<tr>
    <td>Индексы на join-столбцах</td>
    <td><code>CREATE INDEX idx_dept_id ON employees(department_id)</code></td>
    <td>Значительно ускоряет выполнение</td>
</tr>
<tr>
    <td>SELECT только нужные столбцы</td>
    <td><code>SELECT e.name, d.department_name</code></td>
    <td>Уменьшает нагрузку на БД</td>
</tr>
<tr>
    <td>Порядок соединений</td>
    <td>Сначала маленькие таблицы</td>
    <td>Оптимизирует производительность</td>
</tr>
</table>

Пример оптимизированного запроса:

```sql
-- Хорошо оптимизированный запрос
SELECT 
    e.name,
    e.email,
    d.department_name,
    p.project_name
FROM departments d  -- Начинаем с меньшей таблицы
INNER JOIN employees e ON d.id = e.department_id
LEFT JOIN projects p ON e.id = p.employee_id
WHERE d.active = true
    AND e.salary > 50000
ORDER BY e.name;
```

↑ К содержанию

<span id="частые-ошибки"></span>

Частые ошибки

<big>Избегайте этих распространенных ошибок при работе с JOIN.</big>

<table border="1" style="width:100%">
<tr>
    <th>Ошибка</th>
    <th>Неправильно</th>
    <th>Правильно</th>
</tr>
<tr>
    <td>Отсутствие условия JOIN</td>
    <td><code>FROM table1 JOIN table2</code></td>
    <td><code>FROM table1 JOIN table2 ON condition</code></td>
</tr>
<tr>
    <td>Неоднозначные имена столбцов</td>
    <td><code>SELECT name FROM e JOIN d ON id = id</code></td>
    <td><code>SELECT e.name FROM employees e JOIN departments d ON e.id = d.id</code></td>
</tr>
<tr>
    <td>WHERE вместо LEFT JOIN</td>
    <td><code>SELECT * FROM a LEFT JOIN b ON a.id = b.id WHERE b.value = 1</code></td>
    <td><code>SELECT * FROM a LEFT JOIN b ON a.id = b.id AND b.value = 1</code></td>
</tr>
<tr>
    <td>Избыточные соединения</td>
    <td>Много ненужных LEFT JOIN</td>
    <td>Используйте только необходимые соединения</td>
</tr>
</table>

Пример исправления типичной ошибки:

```sql
-- НЕПРАВИЛЬНО: WHERE превращает LEFT JOIN в INNER JOIN
SELECT e.name, d.department_name
FROM employees e
LEFT JOIN departments d ON e.department_id = d.id
WHERE d.department_name = 'IT';  -- Это фильтрует NULL значения!

-- ПРАВИЛЬНО: условие в ON или отдельная обработка NULL
SELECT e.name, d.department_name
FROM employees e
LEFT JOIN departments d ON e.department_id = d.id AND d.department_name = 'IT';

-- ИЛИ
SELECT e.name, d.department_name
FROM employees e
LEFT JOIN departments d ON e.department_id = d.id
WHERE d.department_name = 'IT' OR d.department_name IS NULL;
```

↑ К содержанию

---

Теги: #SQL #JOIN #БазыДанных #INNER_JOIN #LEFT_JOIN #RIGHT_JOIN #FULL_OUTER_JOIN #CROSS_JOIN #SQL_оптимизация

Категории: [[Базы данных]] [[SQL]] [[Операции соединения]]

Связанные темы:

· [[Подзапросы в SQL]]
· [[Индексы и оптимизация запросов]]
· [[Агрегатные функции в SQL]]
· [[Транзакции и блокировки]]
· [[Нормализация баз данных]]

```