```markdown
# Преобразование типов данных в SQL

## Содержание ^k9p2r4m7x
- [Введение](#^a1b2c3d4e5)
- [Неявное преобразование типов](#^f6g7h8i9j0)
- [Явное преобразование типов](#^k1l2m3n4o5)
  - [Функция CAST](#^p6q7r8s9t0)
  - [Функция CONVERT](#^u1v2w3x4y5)
  - [Специфичные функции СУБД](#^z6a7b8c9d0)
- [Преобразование основных типов данных](#^e1f2g3h4i5)
  - [Числовые преобразования](#^j6k7l8m9n0)
  - [Строковые преобразования](#^o1p2q3r4s5)
  - [Преобразования даты и времени](#^t6u7v8w9x0)
  - [Логические преобразования](#^y1z2a3b4c5)
- [Обработка ошибок преобразования](#^d6e7f8g9h0)
- [Лучшие практики](#^i1j2k3l4m5)
- [Заключение](#^n6o7p8q9r0)

## Введение ^a1b2c3d4e5
Преобразование типов данных - это фундаментальная операция в SQL, которая позволяет изменять тип данных значения из одного формата в другой. Это необходимо для корректной работы с данными в выражениях, сравнениях и агрегатных функциях.

<big>**Основные сценарии преобразования типов:**</big>

- Сравнение значений разных типов данных
- Объединение данных из различных источников
- Форматирование вывода для отчетности
- Обеспечение совместимости в выражениях
- Подготовка данных для экспорта

<small>Правильное преобразование типов критически важно для производительности запросов и предотвращения ошибок выполнения.</small>

[↑ К содержанию](#^k9p2r4m7x)

## Неявное преобразование типов ^f6g7h8i9j0
Неявное преобразование происходит автоматически, когда СУБД пытается выполнить операцию с данными разных типов без явного указания программиста.

**Примеры неявного преобразования:**

```sql
-- Сравнение строки и числа (строка преобразуется в число)
SELECT * FROM products WHERE price > '100';

-- Конкатенация числа и строки (число преобразуется в строку)
SELECT 'Цена: ' + price FROM products;

-- Сложение даты и числа (число преобразуется в интервал дней)
SELECT order_date + 7 FROM orders;

-- Использование в условиях WHERE
SELECT * FROM users WHERE age > '25'; -- '25' преобразуется в число
```

**Разбор примеров:**
- В первом примере строка `'100'` автоматически преобразуется в число для сравнения
- Во втором примере числовой `price` преобразуется в строку для конкатенации
- В третьем примере число `7` преобразуется в интервал `7 days`
- В четвертом примере строка `'25'` преобразуется в число для сравнения

**Потенциальные проблемы неявного преобразования:**

```sql
-- Опасное неявное преобразование
SELECT * FROM products WHERE product_id = 'ABC123';
-- Если product_id - число, 'ABC123' не сможет преобразоваться → ошибка

-- Потеря точности
SELECT 10 / 3;      -- Результат: 3 (целочисленное деление)
SELECT 10 / 3.0;    -- Результат: 3.333... (деление с плавающей точкой)
```

**Рекомендации:**
- Избегайте неявного преобразования в критических операциях
- Используйте явное преобразование для ясности кода
- Проверяйте совместимость типов в сложных выражениях

[↑ К содержанию](#^k9p2r4m7x)

## Явное преобразование типов ^k1l2m3n4o5
Явное преобразование выполняется с использованием специальных функций и операторов, что делает код более понятным и предсказуемым.

### Функция CAST ^p6q7r8s9t0
Функция CAST является стандартом SQL и поддерживается большинством СУБД для явного преобразования типов.

**Синтаксис:**
```sql
CAST(expression AS target_type)
```

**Разбор синтаксиса:**
- `expression` - значение или столбец для преобразования
- `target_type` - целевой тип данных
- `AS` - обязательное ключевое слово

**Примеры использования CAST:**

```sql
-- Преобразование строки в число
SELECT CAST('123' AS INTEGER) as number_value;
SELECT CAST(price AS VARCHAR(10)) as price_text FROM products;

-- Преобразование даты
SELECT CAST('2024-01-15' AS DATE) as date_value;
SELECT CAST(order_date AS VARCHAR(20)) as date_text FROM orders;

-- Преобразование между числовыми типами
SELECT CAST(123.456 AS DECIMAL(10,2)) as rounded_value;
SELECT CAST(salary AS BIGINT) as big_salary FROM employees;

-- Преобразование для вычислений
SELECT 
    quantity,
    unit_price,
    CAST(quantity AS DECIMAL) * unit_price as total_amount
FROM order_items;
```

**Особенности CAST:**
- Стандарт SQL - работает в большинстве СУБД
- Четкий и понятный синтаксис
- Поддерживает широкий диапазон преобразований
- Может быть менее гибким чем специфичные функции

[↑ К содержанию](#^k9p2r4m7x)

### Функция CONVERT ^u1v2w3x4y5
Функция CONVERT является альтернативой CAST в некоторых СУБД (особенно SQL Server) и предоставляет дополнительные возможности форматирования.

**Синтаксис (SQL Server):**
```sql
CONVERT(target_type, expression [, style])
```

**Синтаксис (MySQL):**
```sql
CONVERT(expression, target_type)
```

**Разбор параметров:**
- `target_type` - целевой тип данных
- `expression` - значение для преобразования
- `style` - необязательный параметр форматирования (только SQL Server)

**Примеры CONVERT в SQL Server:**

```sql
-- Базовое преобразование
SELECT CONVERT(INT, '123') as number_value;
SELECT CONVERT(VARCHAR, price) as price_text FROM products;

-- Преобразование дат с форматированием
SELECT CONVERT(VARCHAR, GETDATE(), 101) as us_date;      -- MM/DD/YYYY
SELECT CONVERT(VARCHAR, GETDATE(), 103) as eu_date;      -- DD/MM/YYYY
SELECT CONVERT(VARCHAR, GETDATE(), 120) as iso_date;     -- YYYY-MM-DD HH:MI:SS

-- Преобразование числовых типов
SELECT CONVERT(DECIMAL(10,2), 123.4567) as rounded_value;
SELECT CONVERT(MONEY, total_amount) as money_value FROM orders;
```

**Примеры CONVERT в MySQL:**

```sql
-- Преобразование в MySQL
SELECT CONVERT('123', SIGNED INTEGER) as number_value;
SELECT CONVERT(price, CHAR) as price_text FROM products;
SELECT CONVERT('2024-01-15', DATE) as date_value;
```

**Сравнение CAST и CONVERT:**

<table>
<tr>
<td><strong>Характеристика</strong></td>
<td><strong>CAST</strong></td>
<td><strong>CONVERT</strong></td>
</tr>
<tr>
<td>Стандарт SQL</td>
<td>Да (SQL-92)</td>
<td>Нет (специфична для СУБД)</td>
</tr>
<tr>
<td>Форматирование</td>
<td>Нет</td>
<td>Да (в SQL Server)</td>
</tr>
<tr>
<td>Читаемость</td>
<td>Выше</td>
<td>Ниже</td>
</tr>
<tr>
<td>Поддержка СУБД</td>
<td>Все основные</td>
<td>Ограниченная</td>
</tr>
</table>

[↑ К содержанию](#^k9p2r4m7x)

### Специфичные функции СУБД ^z6a7b8c9d0
Различные СУБД предоставляют собственные функции для преобразования типов, которые могут быть более удобными в определенных сценариях.

**PostgreSQL функции:**

```sql
-- TO_CHAR, TO_NUMBER, TO_DATE
SELECT TO_CHAR(CURRENT_DATE, 'DD/MM/YYYY') as formatted_date;
SELECT TO_NUMBER('123.45', '999D99') as number_value;
SELECT TO_DATE('15/01/2024', 'DD/MM/YYYY') as date_value;

-- Преобразование с :: оператором
SELECT '123'::INTEGER as number_value;
SELECT 123.456::DECIMAL(10,2) as rounded_value;
SELECT CURRENT_TIMESTAMP::DATE as today_date;

-- Функции для JSON
SELECT '{"name": "John"}'::JSON as json_data;
SELECT json_column::TEXT as json_text FROM table_name;
```

**MySQL функции:**

```sql
-- DATE_FORMAT, STR_TO_DATE
SELECT DATE_FORMAT(NOW(), '%Y-%m-%d') as formatted_date;
SELECT STR_TO_DATE('15,01,2024', '%d,%m,%Y') as date_value;

-- Числовые преобразования
SELECT FORMAT(1234.567, 2) as formatted_number; -- 1,234.57
SELECT CONV('FF', 16, 10) as hex_to_decimal;    -- 255

-- Бинарные преобразования
SELECT BIN(10) as binary_value;    -- 1010
SELECT HEX(255) as hex_value;      -- FF
```

**SQL Server функции:**

```sql
-- PARSE, TRY_PARSE, TRY_CONVERT
SELECT PARSE('15/01/2024' AS DATE USING 'ru-RU') as date_value;
SELECT TRY_PARSE('ABC' AS INT) as safe_conversion; -- NULL вместо ошибки
SELECT TRY_CONVERT(DATETIME, 'invalid') as safe_date; -- NULL

-- Форматирование
SELECT FORMAT(1234.56, 'C', 'en-US') as currency; -- $1,234.56
SELECT FORMAT(GETDATE(), 'yyyy-MM-dd') as iso_date;

-- Строковые преобразования
SELECT STR(123.45, 10, 2) as string_number; -- '    123.45'
```

**Oracle функции:**

```sql
-- TO_CHAR, TO_NUMBER, TO_DATE
SELECT TO_CHAR(SYSDATE, 'YYYY-MM-DD') FROM DUAL;
SELECT TO_NUMBER('123.45') FROM DUAL;
SELECT TO_DATE('2024-01-15', 'YYYY-MM-DD') FROM DUAL;

-- Преобразования больших объектов
SELECT TO_CLOB(text_column) FROM documents;
SELECT TO_BLOB(hex_string) FROM binary_data;
```

[↑ К содержанию](#^k9p2r4m7x)

## Преобразование основных типов данных ^e1f2g3h4i5
### Числовые преобразования ^j6k7l8m9n0
Преобразование между различными числовыми типами и из/в строковые форматы.

**Преобразование строк в числа:**

```sql
-- Базовые преобразования
SELECT CAST('123' AS INT) as integer_value;
SELECT CAST('123.45' AS DECIMAL(10,2)) as decimal_value;
SELECT CAST('123.456' AS FLOAT) as float_value;

-- Обработка форматированных чисел
SELECT CAST(REPLACE('1,234.56', ',', '') AS DECIMAL(10,2)) as cleaned_number;
SELECT CAST('$123.45' AS MONEY) as money_value; -- SQL Server

-- Безопасное преобразование с проверкой ошибок
-- PostgreSQL
SELECT CASE 
    WHEN '123' ~ '^[0-9]+$' THEN CAST('123' AS INTEGER)
    ELSE NULL 
END as safe_integer;

-- SQL Server
SELECT TRY_CAST('invalid' AS INT) as safe_conversion; -- NULL
```

**Преобразование чисел в строки:**

```sql
-- Базовые преобразования
SELECT CAST(123 AS VARCHAR(10)) as string_number;
SELECT CAST(123.45 AS VARCHAR(20)) as string_decimal;

-- Форматирование чисел
-- PostgreSQL
SELECT TO_CHAR(1234.56, '9,999.99') as formatted; -- '1,234.56'

-- SQL Server  
SELECT FORMAT(1234.56, 'N2') as formatted; -- '1,234.56'

-- MySQL
SELECT FORMAT(1234.567, 2) as formatted; -- '1,234.57'

-- Добавление ведущих нулей
SELECT RIGHT('00000' + CAST(123 AS VARCHAR(5)), 5) as padded_number; -- '00123'
```

**Преобразование между числовыми типами:**

```sql
-- INT to DECIMAL
SELECT CAST(123 AS DECIMAL(10,2)) as decimal_value; -- 123.00

-- DECIMAL to INT (усечение)
SELECT CAST(123.75 AS INT) as truncated; -- 123

-- FLOAT to DECIMAL (округление)
SELECT CAST(123.456789 AS DECIMAL(10,2)) as rounded; -- 123.46

-- Преобразование с сохранением точности
SELECT 
    small_int_column::BIGINT as big_int_value,
    float_column::NUMERIC(15,6) as precise_decimal
FROM data_table;
```

[↑ К содержанию](#^k9p2r4m7x)

### Строковые преобразования ^o1p2q3r4s5
Работа с различными строковыми типами и кодировками.

**Базовые строковые преобразования:**

```sql
-- Преобразование в строки
SELECT CAST(123 AS VARCHAR(10)) as number_text;
SELECT CAST(CURRENT_DATE AS VARCHAR(20)) as date_text;
SELECT CAST(TRUE AS VARCHAR(5)) as boolean_text; -- 'true'

-- Преобразование из строк
SELECT CAST('123' AS INTEGER) as string_to_number;
SELECT CAST('2024-01-15' AS DATE) as string_to_date;
SELECT CAST('true' AS BOOLEAN) as string_to_boolean; -- PostgreSQL

-- Работа с кодировками
-- PostgreSQL
SELECT CONVERT_TO('текст', 'UTF8') as utf8_bytes;
SELECT CONVERT_FROM(utf8_bytes, 'UTF8') as text_value;

-- MySQL
SELECT CONVERT('текст' USING utf8mb4) as utf8_text;
```

**Форматирование строк:**

```sql
-- Конкатенация с преобразованием
SELECT 'Заказ №' || CAST(order_id AS VARCHAR(10)) as order_description 
FROM orders;

-- Верхний/нижний регистр
SELECT UPPER(CAST('Text' AS VARCHAR(10))) as upper_text;
SELECT LOWER(CAST('TEXT' AS VARCHAR(10))) as lower_text;

-- Обрезка и дополнение
SELECT LPAD(CAST(123 AS VARCHAR(5)), 5, '0') as padded; -- '00123'
SELECT RPAD(CAST('ABC' AS VARCHAR(5)), 5, '-') as padded; -- 'ABC--'

-- SQL Server: форматирование дат в строки
SELECT FORMAT(order_date, 'yyyy-MM-dd') as iso_date FROM orders;
```

**Работа с UNICODE и специальными символами:**

```sql
-- Преобразование в UNICODE
-- SQL Server
SELECT UNICODE('A') as unicode_value; -- 65
SELECT N'Юникод текст' as unicode_string;

-- PostgreSQL
SELECT ASCII('A') as ascii_value;
SELECT 'Юникод текст'::VARCHAR as unicode_string;

-- Экранирование специальных символов
SELECT QUOTE_IDENT('table-name') as quoted_identifier; -- "table-name"
SELECT QUOTE_LITERAL('O''Reilly') as quoted_string; -- 'O''Reilly'
```

[↑ К содержанию](#^k9p2r4m7x)

### Преобразования даты и времени ^t6u7v8w9x0
Преобразование между различными форматами дат и временных меток.

**Строка в дату:**

```sql
-- Стандартные форматы
SELECT CAST('2024-01-15' AS DATE) as iso_date;
SELECT CAST('2024-01-15 14:30:00' AS TIMESTAMP) as timestamp_value;

-- Произвольные форматы
-- PostgreSQL
SELECT TO_DATE('15/01/2024', 'DD/MM/YYYY') as eu_date;
SELECT TO_TIMESTAMP('15-01-2024 14:30', 'DD-MM-YYYY HH24:MI') as custom_timestamp;

-- SQL Server
SELECT CONVERT(DATE, '15/01/2024', 103) as eu_date; -- DD/MM/YYYY
SELECT PARSE('15 января 2024' AS DATE USING 'ru-RU') as localized_date;

-- MySQL
SELECT STR_TO_DATE('15,01,2024', '%d,%m,%Y') as eu_date;
SELECT DATE('2024-01-15 14:30:00') as date_part;
```

**Дата в строку:**

```sql
-- Стандартное преобразование
SELECT CAST(CURRENT_DATE AS VARCHAR(10)) as date_string;
SELECT CAST(CURRENT_TIMESTAMP AS VARCHAR(20)) as timestamp_string;

-- Форматированное преобразование
-- PostgreSQL
SELECT TO_CHAR(CURRENT_DATE, 'DD.MM.YYYY') as formatted_date;
SELECT TO_CHAR(CURRENT_TIMESTAMP, 'YYYY-MM-DD HH24:MI:SS') as iso_timestamp;

-- SQL Server
SELECT FORMAT(GETDATE(), 'dd.MM.yyyy') as formatted_date;
SELECT CONVERT(VARCHAR, GETDATE(), 120) as iso_format; -- YYYY-MM-DD HH:MI:SS

-- MySQL
SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s') as formatted_timestamp;
```

**Преобразование временных интервалов:**

```sql
-- Интервалы в строки
SELECT CAST(INTERVAL '5 days' AS VARCHAR) as interval_string;

-- Извлечение компонентов даты
SELECT EXTRACT(YEAR FROM order_date) as order_year FROM orders;
SELECT DATEPART(MONTH, order_date) as order_month FROM orders; -- SQL Server

-- Арифметика с датами
SELECT order_date + INTERVAL '7 days' as due_date FROM orders;
SELECT DATEADD(DAY, 7, order_date) as due_date FROM orders; -- SQL Server
```

[↑ К содержанию](#^k9p2r4m7x)

### Логические преобразования ^y1z2a3b4c5
Работа с булевыми значениями в различных СУБД.

**Преобразование в булев тип:**

```sql
-- PostgreSQL (поддержка BOOLEAN)
SELECT CAST('true' AS BOOLEAN) as bool_true;
SELECT CAST('false' AS BOOLEAN) as bool_false;
SELECT CAST(1 AS BOOLEAN) as bool_from_int; -- true
SELECT CAST(0 AS BOOLEAN) as bool_from_zero; -- false

-- Из строковых представлений
SELECT 
    CASE 
        WHEN status = 'ACTIVE' THEN TRUE
        ELSE FALSE
    END as is_active
FROM users;

-- Из числовых значений
SELECT 
    CASE 
        WHEN flag = 1 THEN TRUE
        WHEN flag = 0 THEN FALSE
        ELSE NULL
    END as boolean_flag
FROM settings;
```

**Преобразование из булева типа:**

```sql
-- В строки
SELECT CAST(TRUE AS VARCHAR(5)) as string_true; -- 'true'
SELECT CAST(FALSE AS VARCHAR(5)) as string_false; -- 'false'

-- В числа
SELECT CAST(TRUE AS INTEGER) as int_true; -- 1
SELECT CAST(FALSE AS INTEGER) as int_false; -- 0

-- Форматированное представление
SELECT 
    active_flag,
    CASE 
        WHEN active_flag THEN 'Да'
        ELSE 'Нет'
    END as russian_yes_no
FROM products;
```

**Эмуляция булевых типов в СУБД без их поддержки:**

```sql
-- MySQL (нет BOOLEAN типа)
SELECT 
    is_active,
    IF(is_active = 1, 'Активен', 'Неактивен') as status_text
FROM users;

-- SQL Server (BIT тип)
SELECT 
    CAST(is_active AS BIT) as bit_flag,
    CASE 
        WHEN is_active = 1 THEN 'Включено'
        ELSE 'Выключено'
    END as state_text
FROM settings;
```

[↑ К содержанию](#^k9p2r4m7x)

## Обработка ошибок преобразования ^d6e7f8g9h0
Обработка ситуаций, когда преобразование типов невозможно или может вызвать ошибки.

**Безопасные функции преобразования:**

```sql
-- SQL Server: TRY_CAST, TRY_CONVERT, TRY_PARSE
SELECT TRY_CAST('invalid' AS INT) as safe_int; -- NULL
SELECT TRY_CONVERT(DATETIME, 'not a date') as safe_date; -- NULL
SELECT TRY_PARSE('ABC' AS INT) as safe_parse; -- NULL

-- PostgreSQL: обработка через исключения
BEGIN
    SELECT CAST('invalid' AS INTEGER);
EXCEPTION 
    WHEN invalid_text_representation THEN
        NULL; -- Обработка ошибки
END;

-- MySQL: использование с функциями проверки
SELECT 
    CASE 
        WHEN '123' REGEXP '^[0-9]+$' THEN CAST('123' AS UNSIGNED)
        ELSE NULL
    END as safe_conversion;
```

**Пользовательские функции для безопасного преобразования:**

```sql
-- PostgreSQL безопасное преобразование в INT
CREATE OR REPLACE FUNCTION safe_cast_to_int(text_value TEXT, default_value INT DEFAULT NULL)
RETURNS INT AS $$
BEGIN
    RETURN text_value::INT;
EXCEPTION 
    WHEN invalid_text_representation THEN
        RETURN default_value;
END;
$$ LANGUAGE plpgsql;

-- Использование
SELECT safe_cast_to_int('123') as good_value; -- 123
SELECT safe_cast_to_int('abc') as bad_value; -- NULL
SELECT safe_cast_to_int('abc', 0) as with_default; -- 0
```

**Валидация данных перед преобразованием:**

```sql
-- Проверка числового формата
SELECT 
    input_value,
    CASE 
        WHEN input_value ~ '^[-+]?[0-9]*\.?[0-9]+$' THEN CAST(input_value AS DECIMAL)
        ELSE NULL
    END as validated_number
FROM raw_data;

-- Проверка даты
SELECT 
    date_string,
    CASE 
        WHEN date_string ~ '^\d{4}-\d{2}-\d{2}$' 
             AND TO_DATE(date_string, 'YYYY-MM-DD') IS NOT NULL 
        THEN TO_DATE(date_string, 'YYYY-MM-DD')
        ELSE NULL
    END as validated_date
FROM date_strings;
```

**Обработка NULL и значений по умолчанию:**

```sql
-- COALESCE для значений по умолчанию
SELECT 
    COALESCE(TRY_CAST(text_number AS INT), 0) as safe_int,
    COALESCE(TRY_CONVERT(DATE, text_date), '1900-01-01') as safe_date
FROM conversion_test;

-- Комплексная обработка ошибок
SELECT 
    input_value,
    CASE 
        WHEN TRY_CAST(input_value AS INT) IS NOT NULL 
            THEN CAST(input_value AS INT)
        WHEN TRY_CAST(input_value AS DECIMAL) IS NOT NULL 
            THEN CAST(CAST(input_value AS DECIMAL) AS INT)
        ELSE 0
    END as robust_conversion
FROM problematic_data;
```

[↑ К содержанию](#^k9p2r4m7x)

## Лучшие практики ^i1j2k3l4m5
Эффективное и безопасное использование преобразования типов в SQL.

### Производительность преобразований:
```sql
-- ✅ Эффективно: преобразование в WHERE с индексами
SELECT * FROM orders 
WHERE order_date = CAST('2024-01-15' AS DATE);

-- ❌ Менее эффективно: преобразование столбца
SELECT * FROM orders 
WHERE CAST(order_date AS VARCHAR) = '2024-01-15';

-- ✅ Оптимально: совместимые типы в JOIN
SELECT * 
FROM orders o 
JOIN customers c ON o.customer_id = c.customer_id::INTEGER;

-- ❌ Проблемно: разные типы в JOIN
SELECT * 
FROM orders o 
JOIN customers c ON o.customer_id::VARCHAR = c.customer_id;
```

### Безопасность данных:
```sql
-- ✅ Безопасно: проверка перед преобразованием
SELECT 
    user_input,
    CASE 
        WHEN user_input ~ '^\d+$' THEN user_input::INTEGER
        ELSE NULL
    END as safe_integer
FROM user_data;

-- ✅ Использование безопасных функций
SELECT 
    TRY_CAST(possibly_bad_data AS INT) as safe_conversion,
    COALESCE(TRY_CONVERT(DATE, date_string), CURRENT_DATE) as safe_date
FROM untrusted_source;
```

### Читаемость кода:
```sql
-- ✅ Понятно: явное преобразование с комментариями
SELECT 
    CAST(quantity AS DECIMAL(10,2)) * unit_price as total_amount, -- Преобразование для точности
    CAST(order_date AS VARCHAR(10)) as display_date -- Для форматирования
FROM order_items;

-- ❌ Неясно: неявное преобразование
SELECT quantity * unit_price, order_date 
FROM order_items;
```

### Согласованность типов:
```sql
-- ✅ Согласовано: единый подход в проекте
-- Все даты хранятся как DATE, все суммы как DECIMAL(15,2)
SELECT 
    CAST(transaction_date AS DATE) as clean_date,
    CAST(amount AS DECIMAL(15,2)) as standardized_amount
FROM transactions;

-- ✅ Правильные типы для операций
SELECT 
    -- DECIMAL для денежных расчетов
    CAST(price AS DECIMAL(10,2)) * quantity as line_total,
    -- INT для целочисленных операций  
    CAST(age AS INT) + 1 as next_year_age,
    -- VARCHAR для текстовых операций
    CAST(id AS VARCHAR(20)) + '-REF' as reference_id
FROM data_table;
```

<table>
<tr>
<td><strong>Практика</strong></td>
<td><strong>Рекомендация</strong></td>
<td><strong>Пример</strong></td>
</tr>
<tr>
<td>Производительность</td>
<td>Избегайте преобразования индексированных столбцов</td>
<td>WHERE date_column = CAST(string_date AS DATE)</td>
</tr>
<tr>
<td>Безопасность</td>
<td>Используйте